<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>capture: capture.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="axis-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">capture
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('capture_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">capture.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Capture Interface, for reading images.  
<a href="#details">More...</a></p>

<p><a href="capture_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac658f255cf7f8a0f746cf2735cf976ca"><td class="memItemLeft" align="right" valign="top"><a id="ac658f255cf7f8a0f746cf2735cf976ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#ac658f255cf7f8a0f746cf2735cf976ca">IMAGE_JPEG</a></td></tr>
<tr class="memdesc:ac658f255cf7f8a0f746cf2735cf976ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The media_type for a JPEG stream. (RGB colorspace) <br /></td></tr>
<tr class="separator:ac658f255cf7f8a0f746cf2735cf976ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7da53205a66553ee004eb53b9981ea3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#ae7da53205a66553ee004eb53b9981ea3">IMAGE_UNCOMPRESSED</a></td></tr>
<tr class="memdesc:ae7da53205a66553ee004eb53b9981ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The media_type for an uncompressed YUV stream. YUV Format can be specified using media property option "sdk_format=&lt;format&gt;". See VIDEO_FORMAT_*.  <a href="#ae7da53205a66553ee004eb53b9981ea3">More...</a><br /></td></tr>
<tr class="separator:ae7da53205a66553ee004eb53b9981ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122c4c2c892374645d3709d49776d5ba"><td class="memItemLeft" align="right" valign="top"><a id="a122c4c2c892374645d3709d49776d5ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a122c4c2c892374645d3709d49776d5ba">VIDEO_H264</a></td></tr>
<tr class="memdesc:a122c4c2c892374645d3709d49776d5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The media_type for an H.264 stream. The stream consists of a sequence of packetized network abstraction layer units (NALUs). The first four bytes in the stream defines the lenght of the packet. Media property option "&amp;spsppsenabled=yes|no" can be used to include SPS (Sequence Parameter Set) and PPS (Picture Parameter Set) in the stream. <br /></td></tr>
<tr class="separator:a122c4c2c892374645d3709d49776d5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f0ba26159e75f8f455b7a03d952437"><td class="memItemLeft" align="right" valign="top"><a id="a44f0ba26159e75f8f455b7a03d952437"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VIDEO_FORMAT_Y800</b></td></tr>
<tr class="separator:a44f0ba26159e75f8f455b7a03d952437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548883f2bbf53d1a30a7cf0b4b413d38"><td class="memItemLeft" align="right" valign="top"><a id="a548883f2bbf53d1a30a7cf0b4b413d38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VIDEO_FORMAT_I420</b></td></tr>
<tr class="separator:a548883f2bbf53d1a30a7cf0b4b413d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65a3e03721e2f6b38a8319e62829a39"><td class="memItemLeft" align="right" valign="top"><a id="ae65a3e03721e2f6b38a8319e62829a39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VIDEO_FORMAT_UYVY</b></td></tr>
<tr class="separator:ae65a3e03721e2f6b38a8319e62829a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d30e1a8867754668f62d5463c40e19"><td class="memItemLeft" align="right" valign="top"><a id="ac7d30e1a8867754668f62d5463c40e19"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#ac7d30e1a8867754668f62d5463c40e19">CAPTURE_TIME_FORMAT</a></td></tr>
<tr class="memdesc:ac7d30e1a8867754668f62d5463c40e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format used when printing capture_time. <br /></td></tr>
<tr class="separator:ac7d30e1a8867754668f62d5463c40e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5c38f129d98a8bc4ca031f80d63c6091"><td class="memItemLeft" align="right" valign="top"><a id="a5c38f129d98a8bc4ca031f80d63c6091"></a>
typedef struct _stream_info&#160;</td><td class="memItemRight" valign="bottom"><b>stream_info</b></td></tr>
<tr class="separator:a5c38f129d98a8bc4ca031f80d63c6091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce97c79da3eedea69cdb4b652ab8641"><td class="memItemLeft" align="right" valign="top"><a id="a3ce97c79da3eedea69cdb4b652ab8641"></a>
typedef struct _media_stream&#160;</td><td class="memItemRight" valign="bottom"><b>media_stream</b></td></tr>
<tr class="separator:a3ce97c79da3eedea69cdb4b652ab8641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc32a27faabbb1431e8ae3c67f9478b6"><td class="memItemLeft" align="right" valign="top"><a id="acc32a27faabbb1431e8ae3c67f9478b6"></a>
typedef struct _media_frame&#160;</td><td class="memItemRight" valign="bottom"><b>media_frame</b></td></tr>
<tr class="separator:acc32a27faabbb1431e8ae3c67f9478b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2dfaa9bf42e1097b7ecf5656984fd0"><td class="memItemLeft" align="right" valign="top"><a id="a6e2dfaa9bf42e1097b7ecf5656984fd0"></a>
typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a6e2dfaa9bf42e1097b7ecf5656984fd0">capture_time</a></td></tr>
<tr class="memdesc:a6e2dfaa9bf42e1097b7ecf5656984fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The datatype to hold a timestamp for the time of capture for a frame, measured in nanoseconds for the system uptime (CLOCK_MONOTONIC). <br /></td></tr>
<tr class="separator:a6e2dfaa9bf42e1097b7ecf5656984fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0c8455627728c4bb5194632b8813a67c"><td class="memItemLeft" align="right" valign="top">media_stream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c">capture_open_stream</a> (const char *media_type, const char *media_props)</td></tr>
<tr class="memdesc:a0c8455627728c4bb5194632b8813a67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a new stream of the specified media type with the specified properties.  <a href="#a0c8455627728c4bb5194632b8813a67c">More...</a><br /></td></tr>
<tr class="separator:a0c8455627728c4bb5194632b8813a67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e6daae3c3a8c2b0f8809e32891d58e"><td class="memItemLeft" align="right" valign="top">media_frame *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a64e6daae3c3a8c2b0f8809e32891d58e">capture_get_frame</a> (media_stream *stream)</td></tr>
<tr class="memdesc:a64e6daae3c3a8c2b0f8809e32891d58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a media_frame from an open stream.  <a href="#a64e6daae3c3a8c2b0f8809e32891d58e">More...</a><br /></td></tr>
<tr class="separator:a64e6daae3c3a8c2b0f8809e32891d58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cbbde0f7e3a423f440bfba4cc1998d"><td class="memItemLeft" align="right" valign="top">media_frame **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a99cbbde0f7e3a423f440bfba4cc1998d">capture_get_burst</a> (media_stream *stream)</td></tr>
<tr class="separator:a99cbbde0f7e3a423f440bfba4cc1998d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e894677776d3c87fe6b89c50bb672a8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a8e894677776d3c87fe6b89c50bb672a8">capture_frame_data</a> (const media_frame *frame)</td></tr>
<tr class="memdesc:a8e894677776d3c87fe6b89c50bb672a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the data from the media_frame.  <a href="#a8e894677776d3c87fe6b89c50bb672a8">More...</a><br /></td></tr>
<tr class="separator:a8e894677776d3c87fe6b89c50bb672a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23dafedfa149bd822e65c99660e91ce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#af23dafedfa149bd822e65c99660e91ce">capture_frame_size</a> (const media_frame *frame)</td></tr>
<tr class="memdesc:af23dafedfa149bd822e65c99660e91ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the data size from the media_frame.  <a href="#af23dafedfa149bd822e65c99660e91ce">More...</a><br /></td></tr>
<tr class="separator:af23dafedfa149bd822e65c99660e91ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11036b9735fc884447eae201b1a551ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="capture_8h.html#a6e2dfaa9bf42e1097b7ecf5656984fd0">capture_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a11036b9735fc884447eae201b1a551ec">capture_frame_timestamp</a> (const media_frame *frame)</td></tr>
<tr class="memdesc:a11036b9735fc884447eae201b1a551ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the timestamp of the media_frame, measured in nanoseconds.  <a href="#a11036b9735fc884447eae201b1a551ec">More...</a><br /></td></tr>
<tr class="separator:a11036b9735fc884447eae201b1a551ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27df3bd74459cf2295db6b9a5c85f8c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a27df3bd74459cf2295db6b9a5c85f8c7">capture_frame_height</a> (const media_frame *frame)</td></tr>
<tr class="memdesc:a27df3bd74459cf2295db6b9a5c85f8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the height of the media_frame.  <a href="#a27df3bd74459cf2295db6b9a5c85f8c7">More...</a><br /></td></tr>
<tr class="separator:a27df3bd74459cf2295db6b9a5c85f8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb0d2af46e8dbf080ccceb55db4dd78"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a3fb0d2af46e8dbf080ccceb55db4dd78">capture_frame_width</a> (const media_frame *frame)</td></tr>
<tr class="memdesc:a3fb0d2af46e8dbf080ccceb55db4dd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the width of the media_frame.  <a href="#a3fb0d2af46e8dbf080ccceb55db4dd78">More...</a><br /></td></tr>
<tr class="separator:a3fb0d2af46e8dbf080ccceb55db4dd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ef9be9eef6444bcd321ea9555a339"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a7e1ef9be9eef6444bcd321ea9555a339">capture_frame_stride</a> (const media_frame *frame)</td></tr>
<tr class="memdesc:a7e1ef9be9eef6444bcd321ea9555a339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the stride length of the Y800 media_frame.  <a href="#a7e1ef9be9eef6444bcd321ea9555a339">More...</a><br /></td></tr>
<tr class="separator:a7e1ef9be9eef6444bcd321ea9555a339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f638703b12683a34174f2e745ee4726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a2f638703b12683a34174f2e745ee4726">capture_frame_free</a> (media_frame *frame)</td></tr>
<tr class="memdesc:a2f638703b12683a34174f2e745ee4726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the media_frame retrieved from <a class="el" href="capture_8h.html#a64e6daae3c3a8c2b0f8809e32891d58e" title="Read a media_frame from an open stream. ">capture_get_frame()</a>.  <a href="#a2f638703b12683a34174f2e745ee4726">More...</a><br /></td></tr>
<tr class="separator:a2f638703b12683a34174f2e745ee4726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ad6a85a974c8b2b15a46724fe2b776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a86ad6a85a974c8b2b15a46724fe2b776">capture_burst_free</a> (media_frame **frames)</td></tr>
<tr class="separator:a86ad6a85a974c8b2b15a46724fe2b776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4f781f1304f4ca232b4fd28c390855"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a6b4f781f1304f4ca232b4fd28c390855">capture_close_stream</a> (media_stream *stream)</td></tr>
<tr class="memdesc:a6b4f781f1304f4ca232b4fd28c390855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a running stream.  <a href="#a6b4f781f1304f4ca232b4fd28c390855">More...</a><br /></td></tr>
<tr class="separator:a6b4f781f1304f4ca232b4fd28c390855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e0c6c191fd6057dffa8418295889eb"><td class="memItemLeft" align="right" valign="top">stream_info **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a60e0c6c191fd6057dffa8418295889eb">capture_stream_info_get</a> ()</td></tr>
<tr class="memdesc:a60e0c6c191fd6057dffa8418295889eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the stream currently running on the camera.  <a href="#a60e0c6c191fd6057dffa8418295889eb">More...</a><br /></td></tr>
<tr class="separator:a60e0c6c191fd6057dffa8418295889eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab70da5de06b41dfd9bfc14aa53039b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a8ab70da5de06b41dfd9bfc14aa53039b">capture_stream_info_props</a> (const stream_info *info)</td></tr>
<tr class="memdesc:a8ab70da5de06b41dfd9bfc14aa53039b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the properties of the stream.  <a href="#a8ab70da5de06b41dfd9bfc14aa53039b">More...</a><br /></td></tr>
<tr class="separator:a8ab70da5de06b41dfd9bfc14aa53039b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e408fad85f7ba4ee36a589fb0111eef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a4e408fad85f7ba4ee36a589fb0111eef">capture_stream_info_type</a> (const stream_info *info)</td></tr>
<tr class="memdesc:a4e408fad85f7ba4ee36a589fb0111eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the type of the stream.  <a href="#a4e408fad85f7ba4ee36a589fb0111eef">More...</a><br /></td></tr>
<tr class="separator:a4e408fad85f7ba4ee36a589fb0111eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57524b713c795fd0b42d937ebfcdd177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a57524b713c795fd0b42d937ebfcdd177">capture_stream_info_free</a> (stream_info **info)</td></tr>
<tr class="memdesc:a57524b713c795fd0b42d937ebfcdd177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the array of stream_info acquired by capture_strem_info_get.  <a href="#a57524b713c795fd0b42d937ebfcdd177">More...</a><br /></td></tr>
<tr class="separator:a57524b713c795fd0b42d937ebfcdd177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69099dceedc3264fb7665dba2f9080eb"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#a69099dceedc3264fb7665dba2f9080eb">capture_get_resolutions_list</a> (int channel)</td></tr>
<tr class="memdesc:a69099dceedc3264fb7665dba2f9080eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with all available resolutions for the current capture mode.  <a href="#a69099dceedc3264fb7665dba2f9080eb">More...</a><br /></td></tr>
<tr class="separator:a69099dceedc3264fb7665dba2f9080eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fd378692960dd396b608c480840b81"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="capture_8h.html#ad6fd378692960dd396b608c480840b81">capture_get_optimal_resolutions_list</a> (int channel)</td></tr>
<tr class="memdesc:ad6fd378692960dd396b608c480840b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list with the most optimal resolutions with respect to performance for the current capture mode.  <a href="#ad6fd378692960dd396b608c480840b81">More...</a><br /></td></tr>
<tr class="separator:ad6fd378692960dd396b608c480840b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Capture Interface, for reading images. </p>
<p>The capture interface contains functions for opening and closing an image stream and for reading image frames from the stream.</p>
<p>The media_type parameter of the capture_open_stream function defines what kind of stream to open. Right now It can be <code>IMAGE_JPEG</code> for a JPEG stream or <code>IMAGE_UNCOMPRESSED</code> for a stream of uncompressed YUV images. The default YUV type is planar I420 but other formats can be specified by using the <code>media_props</code> argument to <code><a class="el" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c" title="Opens a new stream of the specified media type with the specified properties. ">capture_open_stream()</a></code>. <b>Note:</b> Retrieval of uncompressed is only supported on products with major version 0 of the capture interface.</p>
<h1><a class="anchor" id="media_props"></a>
Stream properties</h1>
<p>The <code>media_props</code> argument is an extended version of the VAPIX option string. The following options are availble for the different stream types.</p>
<h2><a class="anchor" id="img_jpg"></a>
IMAGE_JPEG</h2>
<p>For JPEG images the <code>media_props</code> argument accepts the same kind of parameters as specified in the VAPIX.</p>
<p>Read more at <a href="http://www.axis.com/techsup/cam_servers/dev/cam_http_api_2.php#api_blocks_image_video_mjpg_video">http://www.axis.com/techsup/cam_servers/dev/cam_http_api_2.php#api_blocks_image_video_mjpg_video</a></p>
<h2><a class="anchor" id="img_yuv"></a>
IMAGE_UNCOMPRESSED</h2>
<p><b>Note:</b> Retrieval of uncompressed is only supported on products with major version 0 of the capture interface.</p>
<p>For uncompressed YUV images the following parameters are defined:</p><ul>
<li>fps=&lt;int&gt;</li>
<li>sdk_format=&lt;string&gt;</li>
<li>resolution=&lt;string&gt;</li>
</ul>
<p>The <b>fps</b> parameter specifies the frame rate of the images being pushed out on the stream.</p>
<p>The <b>sdk_format</b> string is in <em>FOURCC</em> format. A <em>FOURCC</em> is a sequence of four bytes used do identify data formats. Supported formats include:</p><ul>
<li>Y800</li>
<li>I420</li>
<li>UYVY</li>
</ul>
<p>For ARTPEC-4 based products UYVY is native and require no internal conversion</p>
<p>The <b>resolution</b> string specifies the dimensions of the images in the stream. The syntax is the same as the corresponding VAPIX parameter.</p>
<h2><a class="anchor" id="gen"></a>
General properties</h2>
<p>The <b>Burst</b> mode, <code><a class="el" href="capture_8h.html#a99cbbde0f7e3a423f440bfba4cc1998d">capture_get_burst()</a></code> is no longer supported. This function will always return NULL.</p>
<h2><a class="anchor" id="crop"></a>
Cropping</h2>
<p>The new VAPIX parameters <em>cropsize</em> and <em>croppos</em> can be used to read a cropped area from an image. To read an area of 160x120 from an 640x480 image, apply the VAPIX parameters: </p><div class="fragment"><div class="line">?resolution=640x480&amp;croppos=100,0&amp;cropsize=160x120</div></div><!-- fragment --><h2><a class="anchor" id="stride"></a>
Stride</h2>
<p>To support the processing enhancements provided by the RAPP library, uncompressed Y800 images will consist of aligned image data. And the interface defines a row length, called stride. Each uncompressed Y800 image is described by data, width, height and stride:</p>
<p>Pointer to the pixel data. The pixel data buffer is aligned. The alignment number is platform specific and compatible with the RAPP library.</p><ul>
<li><a class="el" href="capture_8h.html#a8e894677776d3c87fe6b89c50bb672a8" title="Obtain the data from the media_frame. ">capture_frame_data()</a></li>
</ul>
<p>The width of the image in number of pixels.</p><ul>
<li><p class="startli"><a class="el" href="capture_8h.html#a3fb0d2af46e8dbf080ccceb55db4dd78" title="Obtain the width of the media_frame. ">capture_frame_width()</a></p>
<p class="startli">The height of the image in number of pixels.</p>
</li>
<li><p class="startli"><a class="el" href="capture_8h.html#a27df3bd74459cf2295db6b9a5c85f8c7" title="Obtain the height of the media_frame. ">capture_frame_height()</a></p>
<p class="startli">The length of the rows in the image in bytes. The stride value is aligned and can be greater than the image width.<br />
 The stride of the image needs to be taken into account when working with Y800 images. After the first <em>width</em> bytes of image data, <br />
 the row is padded to achieve the stride. When a Y800 image with a resolution of 350x288 is requested each row has a length of 350 <br />
 bytes image data and then a 2 byte padding, giving a stride of 352.</p>
</li>
<li><a class="el" href="capture_8h.html#a7e1ef9be9eef6444bcd321ea9555a339" title="Obtain the stride length of the Y800 media_frame. ">capture_frame_stride()</a></li>
</ul>
<h2><a class="anchor" id="native"></a>
Architecture dependent interface</h2>
<p>There is also an architecture dependent interface, called native. It can be used to read YUV images in the format native to the current hardware. (UYVY on artpec-3 and artpec-4, NV12 on ambarella-a5s) Through the interface, width and height is specified and a pointer to a buffer of YUV data can be read. The memory for the buffer is reused and it needs to be copied if it is to be saved. If the application need to be fast and the format of YUV or the need to use VAPIX functionality like cropping is not important, then this interface can be useful</p>
<h1><a class="anchor" id="Examples"></a>
Examples</h1>
<p>In this section some examples of how to use the Capture interface is shown.</p>
<h2><a class="anchor" id="ex1"></a>
Example 1</h2>
<p>This will request a stream of JPEG images, with a framerate of 10 images per second. </p><div class="fragment"><div class="line">media_stream *stream = <a class="code" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c">capture_open_stream</a>(<a class="code" href="capture_8h.html#ac658f255cf7f8a0f746cf2735cf976ca">IMAGE_JPEG</a>, <span class="stringliteral">&quot;fps=10&quot;</span>);</div></div><!-- fragment --><h2><a class="anchor" id="ex2"></a>
Example 2</h2>
<p><b>Note:</b> Retrieval of uncompressed is only supported on products with major version 0 of the capture interface.</p>
<p>A more complete example of how to use the capture interface. This will request a stream of Y800 uncompressed images, the different <code>media_props</code> options are also documented in the VAPIX API at <a href="http://www.axis.com/techsup/cam_servers/dev/cam_http_api_index.php">http://www.axis.com/techsup/cam_servers/dev/cam_http_api_index.php</a></p>
<p>The code will retrieve a frame of Y800 data and write it as a pgm-file. The stride is needed to make sure the image gets written correctly. </p><div class="fragment"><div class="line"> <span class="keyword">static</span> <span class="keywordtype">void</span> write_pgm(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> stride) {</div><div class="line">  FILE *fp;</div><div class="line">  <span class="keywordtype">int</span> row, column;</div><div class="line"></div><div class="line">  fp = fopen(<span class="stringliteral">&quot;test.pgm&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);</div><div class="line"></div><div class="line">  fprintf(fp, <span class="stringliteral">&quot;P5\n&quot;</span>);</div><div class="line">  fprintf(fp, <span class="stringliteral">&quot;# CREATOR: Axis Communications AB\n&quot;</span>);</div><div class="line">  fprintf(fp, <span class="stringliteral">&quot;%d %d\n&quot;</span>, width, height);</div><div class="line">  fprintf(fp, <span class="stringliteral">&quot;%d\n&quot;</span>, 255);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (row = 0; row &lt; height; row++)</div><div class="line">    <span class="keywordflow">for</span> (column = 0; column &lt; width; column++)</div><div class="line">      fputc (((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) data)[row * stride + column], fp);</div><div class="line"></div><div class="line">  fclose(fp);</div><div class="line">}</div><div class="line"></div><div class="line"> <span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div><div class="line">  media_frame  *frame;</div><div class="line">  <span class="keywordtype">void</span>     *data;</div><div class="line">  <span class="keywordtype">size_t</span>   size;</div><div class="line">  media_stream *stream;</div><div class="line">  <a class="code" href="capture_8h.html#a6e2dfaa9bf42e1097b7ecf5656984fd0">capture_time</a> timestamp;</div><div class="line"></div><div class="line">  stream = <a class="code" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c">capture_open_stream</a>(<a class="code" href="capture_8h.html#ae7da53205a66553ee004eb53b9981ea3">IMAGE_UNCOMPRESSED</a>, <span class="stringliteral">&quot;fps=25&amp;sdk_format=Y800&amp;resolution=350x288&amp;rotation=180&quot;</span>);</div><div class="line">  frame  = <a class="code" href="capture_8h.html#a64e6daae3c3a8c2b0f8809e32891d58e">capture_get_frame</a>(stream);</div><div class="line"></div><div class="line">  data      = <a class="code" href="capture_8h.html#a8e894677776d3c87fe6b89c50bb672a8">capture_frame_data</a>(frame);</div><div class="line">  width     = <a class="code" href="capture_8h.html#a3fb0d2af46e8dbf080ccceb55db4dd78">capture_frame_width</a>(frame);</div><div class="line">  height    = <a class="code" href="capture_8h.html#a27df3bd74459cf2295db6b9a5c85f8c7">capture_frame_height</a>(frame);</div><div class="line">  stride    = <a class="code" href="capture_8h.html#a7e1ef9be9eef6444bcd321ea9555a339">capture_frame_stride</a>(frame);</div><div class="line">  timestamp = <a class="code" href="capture_8h.html#a11036b9735fc884447eae201b1a551ec">capture_frame_timestamp</a>(frame);</div><div class="line"></div><div class="line">  printf(<span class="stringliteral">&quot;Frame captured at %&quot;</span> <a class="code" href="capture_8h.html#ac7d30e1a8867754668f62d5463c40e19">CAPTURE_TIME_FORMAT</a> <span class="stringliteral">&quot;\n&quot;</span>, timestamp);</div><div class="line">  write_pgm(data, width, height, stride);</div><div class="line"></div><div class="line">  <a class="code" href="capture_8h.html#a2f638703b12683a34174f2e745ee4726">capture_frame_free</a>(frame);</div><div class="line">  <a class="code" href="capture_8h.html#a6b4f781f1304f4ca232b4fd28c390855">capture_close_stream</a>(stream);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="ex3"></a>
Example 3</h2>
<p>An example of how to use the architecture dependent interface. <b>Note:</b> The architecture dependent interface is only supported on products with major version 0 of the capture interface.</p>
<div class="fragment"><div class="line">media_native *nat = <a class="code" href="capture__native_8h.html#a1b29748870a9afb7c65a4e04dcc3bbd7">capture_open_native</a> (640, 480);</div><div class="line"><a class="code" href="capture__native_8h.html#a1834be2e2e1b4cba8f7045a58a6f95dc">capture_start_native</a> (nat);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = <a class="code" href="capture__native_8h.html#a6300a34cce5bbaac769840d57102ba1e">capture_get_image_native</a> (nat);</div><div class="line">process_data (data);</div><div class="line"><a class="code" href="capture__native_8h.html#a4a2f00231fdfe41dc13eec88dc3785b0">capture_close_native</a> (nat);</div></div><!-- fragment --><h2><a class="anchor" id="ex4"></a>
Example 4</h2>
<p>An example of how to use the architecture dependent interface when images from a specific video channel is requested. <b>Note:</b> The architecture dependent interface is only supported on products with major version 0 of the capture interface.</p>
<div class="fragment"><div class="line">media_native *nat = <a class="code" href="capture__native_8h.html#a12d5ca681b891dfdef3c9a1b7595fe2f">capture_open_native_channel</a> (2, 640, 480);</div><div class="line"><a class="code" href="capture__native_8h.html#a1834be2e2e1b4cba8f7045a58a6f95dc">capture_start_native</a> (nat);</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = <a class="code" href="capture__native_8h.html#a6300a34cce5bbaac769840d57102ba1e">capture_get_image_native</a> (nat);</div><div class="line">process_data (data);</div><div class="line"><a class="code" href="capture__native_8h.html#a4a2f00231fdfe41dc13eec88dc3785b0">capture_close_native</a> (nat);</div></div><!-- fragment --><h1><a class="anchor" id="Compilation"></a>
Compilation</h1>
<p>To build a program using the capture interface you need to supply the library name as <code>-lcapture</code>. And you need to include the header file <code><a class="el" href="capture_8h.html" title="Capture Interface, for reading images. ">capture.h</a></code>.</p>
<h1><a class="anchor" id="compile_for_host"></a>
Compilation for a linux host</h1>
<p>The capture interface is available for development and debugging in a PC environment. The library is called capturehost (-lcapturehost)and the interface can read existing mjpeg files. Needed are a Linux PC and an Axis camera or video encoder connected to the PC via LAN. </p>
<h2><a class="anchor" id="restrictionsh"></a>
Restrictions for host</h2>
<pre class="fragment"> Supported formats are:
 - Y800
 - I420
</pre><h2><a class="anchor" id="ex5"></a>
Example host</h2>
<p>This is an example of how to use the capture interface on the host. </p><div class="fragment"><div class="line">media_frame  *frame;</div><div class="line"><span class="keywordtype">void</span>     *data;</div><div class="line"><span class="keywordtype">size_t</span>   size;</div><div class="line">media_stream *stream;</div><div class="line"><a class="code" href="capture_8h.html#a6e2dfaa9bf42e1097b7ecf5656984fd0">capture_time</a> timestamp;</div><div class="line"></div><div class="line">stream = <a class="code" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c">capture_open_stream</a>(<a class="code" href="capture_8h.html#ac658f255cf7f8a0f746cf2735cf976ca">IMAGE_JPEG</a>, <span class="stringliteral">&quot;capture-cameraIP=&lt;IP&gt;&amp;capture-userpass=&lt;user&gt;:&lt;password&gt;sdk_format=Y800&amp;&amp;resolution=176x144&amp;fps=1&quot;</span>);</div><div class="line">frame  = <a class="code" href="capture_8h.html#a64e6daae3c3a8c2b0f8809e32891d58e">capture_get_frame</a>(stream);</div><div class="line"></div><div class="line">data      = <a class="code" href="capture_8h.html#a8e894677776d3c87fe6b89c50bb672a8">capture_frame_data</a>(frame);</div><div class="line">size      = <a class="code" href="capture_8h.html#af23dafedfa149bd822e65c99660e91ce">capture_frame_size</a>(frame);</div><div class="line">timestamp = <a class="code" href="capture_8h.html#a11036b9735fc884447eae201b1a551ec">capture_frame_timestamp</a>(frame);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;Frame captured at %&quot;</span> <a class="code" href="capture_8h.html#ac7d30e1a8867754668f62d5463c40e19">CAPTURE_TIME_FORMAT</a> <span class="stringliteral">&quot;\n&quot;</span>, timestamp);</div><div class="line">process_data(data, size);</div><div class="line"></div><div class="line"><a class="code" href="capture_8h.html#a2f638703b12683a34174f2e745ee4726">capture_frame_free</a>(frame);</div><div class="line"><a class="code" href="capture_8h.html#a6b4f781f1304f4ca232b4fd28c390855">capture_close_stream</a>(stream);</div></div><!-- fragment --><p> Note 1: replace &lt;IP&gt; with the IP address of the camera. Replace &lt;user&gt; with an existing user, and &lt;password&gt; with the password of this user.</p>
<p>Note 2: the capture-camera must be the first item in media_props, capture-pass the second, and followed by all other media_props</p>
<pre class="fragment">Note 3: The capturehost interface will use an http proxy whenever the environment variable http_proxy is set using
the same principle as curl.
</pre><h2><a class="anchor" id="ex5"></a>
Example host</h2>
<p>This is an example of how to use the capturehost interface with an existing mjpeg file.</p>
<p>First, acquire an mjpeg file from a camera. </p><div class="fragment"><div class="line">% curl -s -S -u \&lt;user\&gt;:\&lt;password\&gt; <span class="stringliteral">&quot;http://&lt;IP&gt;/mjpg/video.mjpg?duration=5&amp;resolution=176x144&amp;fps=5&quot;</span> &gt;myfile.mjpeg</div><div class="line">% # Replace \&lt;user\&gt; with an existing user, and \&lt;password\&gt; with the password of the user:</div><div class="line">% curl -s -S -u viewer:secretpassword <span class="stringliteral">&quot;http://192.168.0.90/mjpg/video.mjpg?duration=5&amp;resolution=176x144&amp;fps=5&quot;</span> &gt;myfile.mjpeg</div></div><!-- fragment --><p>Then use this mjpeg file to retrieve gray scale frames. </p><div class="fragment"><div class="line">stream = <a class="code" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c">capture_open_stream</a>(<a class="code" href="capture_8h.html#ae7da53205a66553ee004eb53b9981ea3">IMAGE_UNCOMPRESSED</a>, <span class="stringliteral">&quot;capture-cameraIP=myfile.mjpeg&amp;sdk_format=Y800&amp;fps=1&quot;</span>);</div><div class="line">stream = <a class="code" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c">capture_open_stream</a>(<a class="code" href="capture_8h.html#ae7da53205a66553ee004eb53b9981ea3">IMAGE_UNCOMPRESSED</a>, <span class="stringliteral">&quot;capture-cameraIP=myfile.mjpeg&amp;sdk_format=I420&amp;fps=1&quot;</span>);</div></div><!-- fragment --><p>The capturehost interface is able to reduce the frame rate of an existing mjpeg file selecting a few frames and ignoring the rest, for example, 5 fps can be reduced 1 fps by picking 1 frame and ignoring 4 frames. The capturehost interface can simulate real-time timing of the requested fps by blocking the caller a short while and downscaling the resolution by skipping pixels.</p>
<p>On host it is also possible to read a mjeg file from STDIN. In this case the call to <a class="el" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c" title="Opens a new stream of the specified media type with the specified properties. ">capture_open_stream()</a> takes no capture-cameraIP parameter. </p><div class="fragment"><div class="line">stream = <a class="code" href="capture_8h.html#a0c8455627728c4bb5194632b8813a67c">capture_open_stream</a>(<a class="code" href="capture_8h.html#ac658f255cf7f8a0f746cf2735cf976ca">IMAGE_JPEG</a>, <span class="stringliteral">&quot;fps=1&quot;</span>);</div></div><!-- fragment --><p>For example to use the file sunset.mjpeg with the host program 'my_host_viewer' reading from STDIN: </p><div class="fragment"><div class="line">./my_host_viewer &lt; sunset.mjpeg</div></div><!-- fragment --> </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ae7da53205a66553ee004eb53b9981ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7da53205a66553ee004eb53b9981ea3">&#9670;&nbsp;</a></span>IMAGE_UNCOMPRESSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IMAGE_UNCOMPRESSED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The media_type for an uncompressed YUV stream. YUV Format can be specified using media property option "sdk_format=&lt;format&gt;". See VIDEO_FORMAT_*. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Capture of uncompressed frames is not available on all products. It has been removed in Capture interface of major version 1. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0c8455627728c4bb5194632b8813a67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8455627728c4bb5194632b8813a67c">&#9670;&nbsp;</a></span>capture_open_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">media_stream* capture_open_stream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>media_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>media_props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a new stream of the specified media type with the specified properties. </p>
<p>The function will open a stream of the specified media type in the camera. The stream will be taken from an universal cache. If the media type with the specified properties already is running in the camera, they will share the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">media_type</td><td>The specified media type of the stream.</td></tr>
    <tr><td class="paramname">media_props</td><td>The properties of the media type, represented as VAPIX option string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A structure associated with the stream. </dd></dl>

</div>
</div>
<a id="a64e6daae3c3a8c2b0f8809e32891d58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e6daae3c3a8c2b0f8809e32891d58e">&#9670;&nbsp;</a></span>capture_get_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">media_frame* capture_get_frame </td>
          <td>(</td>
          <td class="paramtype">media_stream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a media_frame from an open stream. </p>
<p>The function will get a frame of data from the stream and return it. The frame contains the data, the size and the timestamp. The frame needs to be freed after use, using capture_frame_free.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The structure associated with the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data frame. </dd></dl>

</div>
</div>
<a id="a99cbbde0f7e3a423f440bfba4cc1998d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cbbde0f7e3a423f440bfba4cc1998d">&#9670;&nbsp;</a></span>capture_get_burst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">media_frame** capture_get_burst </td>
          <td>(</td>
          <td class="paramtype">media_stream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>capture_get_burst is not supported and will always return NULL. </dd></dl>

</div>
</div>
<a id="a8e894677776d3c87fe6b89c50bb672a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e894677776d3c87fe6b89c50bb672a8">&#9670;&nbsp;</a></span>capture_frame_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* capture_frame_data </td>
          <td>(</td>
          <td class="paramtype">const media_frame *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the data from the media_frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The media_frame to obtain data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data, NULL if frame is NULL. </dd></dl>

</div>
</div>
<a id="af23dafedfa149bd822e65c99660e91ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23dafedfa149bd822e65c99660e91ce">&#9670;&nbsp;</a></span>capture_frame_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t capture_frame_size </td>
          <td>(</td>
          <td class="paramtype">const media_frame *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the data size from the media_frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The media_frame to obtain data size from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the data, 0 if frame is NULL. </dd></dl>

</div>
</div>
<a id="a11036b9735fc884447eae201b1a551ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11036b9735fc884447eae201b1a551ec">&#9670;&nbsp;</a></span>capture_frame_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="capture_8h.html#a6e2dfaa9bf42e1097b7ecf5656984fd0">capture_time</a> capture_frame_timestamp </td>
          <td>(</td>
          <td class="paramtype">const media_frame *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the timestamp of the media_frame, measured in nanoseconds. </p>
<p>The returned value is nanoseconds for the system uptime (CLOCK_MONOTONIC).</p>
<p>If the frame is jpeg, the same information is found in the jpeg header.</p>
<p>Additional note: if there are 2 different stream used, with different resolution or framerate, then there is no guarantee, that both streams deliver frames which have the same source image (from the sensor or camera). But if the timestamps are identical, then they have the same source image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The media_frame to obtain timestamp from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The timestamp of the data, 0 if frame is NULL. </dd></dl>

</div>
</div>
<a id="a27df3bd74459cf2295db6b9a5c85f8c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27df3bd74459cf2295db6b9a5c85f8c7">&#9670;&nbsp;</a></span>capture_frame_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t capture_frame_height </td>
          <td>(</td>
          <td class="paramtype">const media_frame *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the height of the media_frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The media_frame to obtain height from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The height of the frame, 0 if frame is NULL. </dd></dl>

</div>
</div>
<a id="a3fb0d2af46e8dbf080ccceb55db4dd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb0d2af46e8dbf080ccceb55db4dd78">&#9670;&nbsp;</a></span>capture_frame_width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t capture_frame_width </td>
          <td>(</td>
          <td class="paramtype">const media_frame *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the width of the media_frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The media_frame to obtain width from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The width of the frame, 0 if frame is NULL. </dd></dl>

</div>
</div>
<a id="a7e1ef9be9eef6444bcd321ea9555a339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1ef9be9eef6444bcd321ea9555a339">&#9670;&nbsp;</a></span>capture_frame_stride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t capture_frame_stride </td>
          <td>(</td>
          <td class="paramtype">const media_frame *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the stride length of the Y800 media_frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The media_frame to obtain stride length from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stride length of the frame, 0 if frame is NULL or not Y800. </dd></dl>

</div>
</div>
<a id="a2f638703b12683a34174f2e745ee4726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f638703b12683a34174f2e745ee4726">&#9670;&nbsp;</a></span>capture_frame_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void capture_frame_free </td>
          <td>(</td>
          <td class="paramtype">media_frame *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the media_frame retrieved from <a class="el" href="capture_8h.html#a64e6daae3c3a8c2b0f8809e32891d58e" title="Read a media_frame from an open stream. ">capture_get_frame()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>pointer to the media_frame received from <a class="el" href="capture_8h.html#a64e6daae3c3a8c2b0f8809e32891d58e" title="Read a media_frame from an open stream. ">capture_get_frame()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a86ad6a85a974c8b2b15a46724fe2b776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ad6a85a974c8b2b15a46724fe2b776">&#9670;&nbsp;</a></span>capture_burst_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void capture_burst_free </td>
          <td>(</td>
          <td class="paramtype">media_frame **&#160;</td>
          <td class="paramname"><em>frames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>capture_burst_free is no longer supported. </dd></dl>

</div>
</div>
<a id="a6b4f781f1304f4ca232b4fd28c390855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4f781f1304f4ca232b4fd28c390855">&#9670;&nbsp;</a></span>capture_close_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void capture_close_stream </td>
          <td>(</td>
          <td class="paramtype">media_stream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a running stream. </p>
<p>The function closes the specified stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The structure associated with the stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e0c6c191fd6057dffa8418295889eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e0c6c191fd6057dffa8418295889eb">&#9670;&nbsp;</a></span>capture_stream_info_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stream_info** capture_stream_info_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the stream currently running on the camera. </p>
<dl class="section return"><dt>Returns</dt><dd>A NULL terminated array of stream_info. </dd></dl>

</div>
</div>
<a id="a8ab70da5de06b41dfd9bfc14aa53039b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab70da5de06b41dfd9bfc14aa53039b">&#9670;&nbsp;</a></span>capture_stream_info_props()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* capture_stream_info_props </td>
          <td>(</td>
          <td class="paramtype">const stream_info *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the properties of the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The stream_info to obtain the properties of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The properties as a media_props option string. </dd></dl>

</div>
</div>
<a id="a4e408fad85f7ba4ee36a589fb0111eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e408fad85f7ba4ee36a589fb0111eef">&#9670;&nbsp;</a></span>capture_stream_info_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* capture_stream_info_type </td>
          <td>(</td>
          <td class="paramtype">const stream_info *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the type of the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The stream_info to obtain the type of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The properties as a media_type string. </dd></dl>

</div>
</div>
<a id="a57524b713c795fd0b42d937ebfcdd177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57524b713c795fd0b42d937ebfcdd177">&#9670;&nbsp;</a></span>capture_stream_info_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void capture_stream_info_free </td>
          <td>(</td>
          <td class="paramtype">stream_info **&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the array of stream_info acquired by capture_strem_info_get. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The stream_info array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69099dceedc3264fb7665dba2f9080eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69099dceedc3264fb7665dba2f9080eb">&#9670;&nbsp;</a></span>capture_get_resolutions_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* capture_get_resolutions_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list with all available resolutions for the current capture mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The videochannel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a string with resolutions. This must be deallocated by the caller using free(). </dd></dl>

</div>
</div>
<a id="ad6fd378692960dd396b608c480840b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fd378692960dd396b608c480840b81">&#9670;&nbsp;</a></span>capture_get_optimal_resolutions_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* capture_get_optimal_resolutions_list </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list with the most optimal resolutions with respect to performance for the current capture mode. </p>
<p>This will be a sub-set from the resolutions achieved by get_resolutions_list(int channel);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The videochannel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a string with resolutions. This must be deallocated by the caller using free(). </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="capture_8h.html">capture.h</a></li>
    <li class="footer">Copyright &copy; 2009-2021 Axis Communications AB. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
