<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>liblarod: Introduction to larod for app developers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="axis-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">liblarod
   &#160;<span id="projectnumber">3.2.65-dirty</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Introduction to larod for app developers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#introduction-to-larod-for-app-developers">Introduction to larod for app developers</a><ul>
<li><a href="#overview">Overview</a><ul>
<li><a href="#purpose-and-scope">Purpose and scope</a></li>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#features">Features</a><ul>
<li><a href="#easy-to-get-started-with">Easy to get started with</a></li>
<li><a href="#multiple-apps-per-device">Multiple apps per device</a></li>
<li><a href="#asynchronous">Asynchronous</a></li>
<li><a href="#prioritized-jobs">Prioritized jobs</a></li>
<li><a href="#image-preprocessing">Image preprocessing</a></li>
<li><a href="#minimal-overhead">Minimal overhead</a></li>
<li><a href="#capabilities-probing">Capabilities probing</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#zero-copy-and-map-only-once">Zero-copy and map only once</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#concepts-and-workflow">Concepts and workflow</a><ul>
<li><a href="#larodconnection">larodConnection</a></li>
<li><a href="#laroddevice">larodDevice</a></li>
<li><a href="#larodmodel">larodModel</a></li>
<li><a href="#larodtensor">larodTensor</a></li>
<li><a href="#larodjobrequest">larodJobRequest</a></li>
<li><a href="#asynchronous-calls">Asynchronous calls</a></li>
<li><a href="#tensor-tracking-for-performance">Tensor tracking for performance</a></li>
<li><a href="#power-management">Power management</a></li>
</ul>
</li>
<li><a href="#backward-compatibility">Backward compatibility</a><ul>
<li><a href="#abi-backward-compatibility">ABI backward compatibility</a></li>
<li><a href="#api-backward-compatibility">API backward compatibility</a></li>
</ul>
</li>
<li><a href="#future-features">Future features</a><ul>
<li><a href="#custom-layers">Custom layers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Overview</h2>
<p>larod provides a simple unified C API for running machine learning and image preprocessing efficiently. No matter what a particular device can provide in terms of hardware for such operations – be it some specialized deep learning hardware accelerator or simply an ARM CPU – the larod API is all you need to access it.</p>
<h3>Purpose and scope</h3>
<p>Though the larod API is in some sense quite similar to libraries like Tensorflow Lite and ARMNN the purpose and scope of larod is actually rather different. The main purpose is to wrap other frameworks (like Tensorflow Lite) and thus let users access various different devices (exposing different APIs) through a single unified API. So an application could for example run both preprocessing on a GPU and neural network inference on an ARM CPU on the same device using only the larod API. The native APIs for these devices may be completely different, for example OpenCL and Tensorflow Lite respectively, but larod abstracts these into one simple and unified API.</p>
<p>Furthermore the larod stack is designed to solve a number of other problems as well, for instance related to security, power management and asynchronicity. Please see <a href="#features">features</a> and <a href="#future-features">future features</a> below for more on this.</p>
<h3>Architecture</h3>
<p>larod is made up of two components:</p><ul>
<li><em>liblarod</em>: This is the shared library with which applications link dynamically to use larod. As an app developer liblarod, and <code><a class="el" href="larod_8h.html" title="Main larod header file. ">larod.h</a></code> in particular, will be your interface.</li>
<li><em>larod service</em>: This is a Linux system service which liblarod communicates with to perform operations on the hardware.</li>
</ul>
<p>By using the functions exposed by liblarod, an application can load neural network models and define preprocessing operations (crop, scale, image color format convert). These models are then used together with input data to create job requests, which are sent to the larod service for execution. Model data as well as input and output data are represented by file descriptors in liblarod.</p>
<p>Below we see an example of two apps using larod on a device that have three different devices supported by larod.</p>
<div class="fragment"><div class="line">         .-----------.      .-----------.</div><div class="line">         |           |      |           |</div><div class="line">         |   App 1   |      |   App 2   |</div><div class="line">         |           |      |           |</div><div class="line">         &#39;---------^-&#39;      &#39;-^---------&#39;</div><div class="line">                   |          |</div><div class="line">                 Dynamic linking</div><div class="line">                   |          |</div><div class="line">                .--v----------v--.</div><div class="line">                |                |</div><div class="line">                |    liblarod    |</div><div class="line">                |                |</div><div class="line">                &#39;-------^--------&#39;</div><div class="line">                        |</div><div class="line">               D-Bus and Unix socket</div><div class="line">                        |</div><div class="line">                .-------v--------.</div><div class="line">                |                |</div><div class="line">                |     larod      |</div><div class="line">       .--------&gt;    service     &lt;--------.</div><div class="line">       |        |                |        |</div><div class="line">       |        &#39;-------^--------&#39;        |</div><div class="line">       |                |                 |</div><div class="line">       |    Device-native SW interfaces   |</div><div class="line">       |                |                 |</div><div class="line">.------v-----.    .-----v------.    .-----v------.</div><div class="line">|            |    |            |    |            |</div><div class="line">|  Device A  |    |  Device B  |    |  Device C  |</div><div class="line">|            |    |            |    |            |</div><div class="line">&#39;------------&#39;    &#39;------------&#39;    &#39;------------&#39;</div></div><!-- fragment --><p>Both apps in this example can access all three devices through the same API though the devices' native SW interfaces may be completely different. The larod service will arbitrate job scheduling between the apps to the supported devices.</p>
<h3>Features</h3>
<h4>Easy to get started with</h4>
<p>The larod API is very well documented and there are several basic example applications that exhibit how to use it in practice. A simplified <a href="#concepts-and-workflow">workflow</a> is described below together with the essential concepts in liblarod. The `larod-client` command line tool is a good start for interacting with the larod service.</p>
<h4>Multiple apps per device</h4>
<p>Many runtime libraries shipped with hardware accelerators (devices) for e.g. exercising neural networks will only let one process (application) access the hardware at the same time. This is of course a problem if there are multiple applications running on the device wanting to run inferences on the hardware at the same time. larod solves this problem by having the larod service acting as a proxy process, "owning" the hardware, through which other applications can access the accelerator.</p>
<h4>Asynchronous</h4>
<p>For any possibly time consuming calls to larod – such as loading a model or running a neural network inference – there are asynchronous versions in larod. This implies that one can for example queue up multiple inferences (possibly on different devices) at once without blocking the program execution of one’s application. Note that larod provides such an interface even though the device used has a native SW interface that does not support asynchronous calls.</p>
<h4>Prioritized jobs</h4>
<p>Sometimes certain jobs are more important to have finish more quickly than others. For example in the case of alternating an object detection model with a classifier model running inferences on the boxes obtained by the object detector. If the object detector must always run for every frame (say 30 fps) and a lot of boxes have been detected, all the classification inferences may block the object detector. To this end priority on inferences are supported in larod. So in this example the object detector inferences could use a higher priority making larod choose those over classification inferences whenever multiple jobs are in the queue.</p>
<h4>Image preprocessing</h4>
<p>larod has an interface for simply defining image preprocessing operations like crop, scale, image color format convert, and supports several devices that can perform such operations. Read more on this in preprocessing.md.</p>
<h4>Minimal overhead</h4>
<p>In designing and implementing larod, performance has been of utmost importance. Thus one should expect very little overhead (and indeed benchmarks confirm this) compared to using a native runtime library directly.</p>
<h4>Capabilities probing</h4>
<p>After loading a model into larod one can through calls to larod extract information from the model, e.g. about the models input or output tensors. For example if one has not constructed the model on one’s own, one may want to know what kind of input tensor(s) the model requires: What is the data type? The layout? The dimensions? larod has the answers!</p>
<h4>Security</h4>
<p>In order for an application to use an accelerator it must have the privileges to do so. Without larod that would mean that for some accelerators an application would get the rights to do things that they should not be allowed to do, like writing to memory that must not be touched. With larod however the applications require no such permissions as larod acts as a proxy process which have all those necessary permissions, through which the applications communicate with the hardware.</p>
<h4>Zero-copy and map only once</h4>
<p>The larod API provides a simple way to avoid any memory copies or mappings of input and output tensor data that are possible to avoid. The application simply declares how their buffers may be accessed and whether they will be used repeatedly, and then larod will take all measures possible to optimize memory accesses on these buffers. This implies both that larod jobs run faster and that larod uses the CPU less so as to leave more resources to other processes.</p>
<h2>Concepts and workflow</h2>
<p>The basic workflow of running a job with larod is as follows:</p><ul>
<li>Create a <code>larodConnection</code>.</li>
<li>Retrieve a suitable <code>larodDevice</code>.</li>
<li>Construct a <code>larodModel</code> on the selected device.</li>
<li>Construct input/output <code>larodTensor</code>s and set up their file descriptors pointing to the respective data buffers.</li>
<li>Create a job request out of the <code>larodModel</code> and <code>larodTensor</code> handles.</li>
<li>Execute the job request.</li>
</ul>
<p>A brief description of each step is given below. For details about each function call, see <code><a class="el" href="larod_8h.html" title="Main larod header file. ">larod.h</a></code>.</p>
<h3>larodConnection</h3>
<p>Connecting to the larod service and creating a <code>larodConnection</code> is as simple as </p><div class="fragment"><div class="line"><a class="code" href="structlarodError.html">larodError</a>* error = NULL;</div><div class="line"><a class="code" href="larod_8h.html#adf976f1fb816101078a7ac0b49a78294">larodConnection</a>* conn = NULL;</div><div class="line"></div><div class="line"><a class="code" href="larod_8h.html#ab7337d6d6663c0e45326022503927851">larodConnect</a>(&amp;conn, &amp;error);</div></div><!-- fragment --><p> The <code>larodConnection</code> represents the session that an application has with the larod service and is used in all the calls that interact with the service.</p>
<h3>larodDevice</h3>
<p>The <code>larodDevice</code> struct acts as an abstraction and handle to a specific device and its corresponding native software interface. A <code>larodDevice</code> does not necessarily have to mean something external like a deep-learning accelerator; it can also refer to a software interface that runs on the CPU itself.</p>
<p>A device in larod has a name and an instance number. The name is represented as a string and is usually provided by the user. Refer to preprocessing.md and nn-inference to look up the names of the supported preprocessing- and inference devices. The instance number of a device (starting from zero) represents a separate entity of that device and serves to distinguish multiple identical devices with the same name.</p>
<p>Before loading a model to run jobs with, a device must be retrieved with e.g. the following API function:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="larod_8h.html#aef607537eb94843735472c4afba5fd87">larodDevice</a>* dev = <a class="code" href="larod_8h.html#a29a9707a190c2d0c44f7e50f942b2621">larodGetDevice</a>(conn, <span class="stringliteral">&quot;cpu-tflite&quot;</span>, 0, &amp;error);</div></div><!-- fragment --><p>The example above will return a device handle to CPU-based TFLite backend. This handle can then be used when loading a model as shown in the following section.</p>
<h3>larodModel</h3>
<p>A model represents a computational task with a set of inputs and outputs. The model is loaded onto a specific backend, specified by a <code>larodDevice</code>. There are two resources that one can use to configure the model:</p>
<ul>
<li>Binary data represented by a file descriptor.</li>
<li>A constructed <code>larodMap</code> that contains a set of parameters.</li>
</ul>
<p>Both the type of data that is accepted as well as available parameters are backend specific. Typically, neural networks are loaded with binary data while certain preprocessing operations can be constructed purely from a <code>larodMap</code>.</p>
<p>For example, a TFLite model can be loaded with </p><div class="fragment"><div class="line">FILE* fpModel = fopen(<span class="stringliteral">&quot;mobilenet.tflite&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>);</div><div class="line"><span class="keywordtype">int</span> fd = fileno(fpModel);</div><div class="line"><a class="code" href="larod_8h.html#a9e56e66ffecad46856d96bc289b6ce5a">larodModel</a>* model = <a class="code" href="larod_8h.html#a41b5e5179aa68b382e024945254a5770">larodLoadModel</a>(conn, fd,</div><div class="line">                                   <a class="code" href="larod_8h.html#a29a9707a190c2d0c44f7e50f942b2621">larodGetDevice</a>(conn, <span class="stringliteral">&quot;cpu-tflite&quot;</span>, 0, NULL),</div><div class="line">                                   <a class="code" href="larod_8h.html#a41ad6dc8e9f9ffebc03faf115167aba5afc936d97349d892279eec5c41c154d41">LAROD_ACCESS_PRIVATE</a>, <span class="stringliteral">&quot;Mobilenet&quot;</span>,</div><div class="line">                                   NULL <span class="comment">/*larodMap*/</span>, &amp;error);</div></div><!-- fragment --><p>Similarly, a preprocessing model can be constructed from a <code>larodMap</code>. The file descriptor argument is omitted by setting it to -1 since there is no model file. </p><div class="fragment"><div class="line"><a class="code" href="larod_8h.html#a480ba7618e79ad250c166c52d216ab79">larodMap</a>* modelParams = <a class="code" href="larod_8h.html#ac7cb26c7b2ef5c99507edd44e7727b0e">larodCreateMap</a>(&amp;error);</div><div class="line"></div><div class="line"><a class="code" href="larod_8h.html#a28e4db02130ffb4c0a19fac84b698ce0">larodMapSetStr</a>(modelParams, <span class="stringliteral">&quot;image.input.format&quot;</span>, <span class="stringliteral">&quot;nv12&quot;</span>, NULL);</div><div class="line"><a class="code" href="larod_8h.html#a3e5686f34427aaa1a2476cc0991adf12">larodMapSetIntArr2</a>(modelParams, <span class="stringliteral">&quot;image.input.size&quot;</span>, 1280, 720, NULL);</div><div class="line"><a class="code" href="larod_8h.html#a28e4db02130ffb4c0a19fac84b698ce0">larodMapSetStr</a>(modelParams, <span class="stringliteral">&quot;image.output.format&quot;</span>, <span class="stringliteral">&quot;rgb-interleaved&quot;</span>, NULL);</div><div class="line"><a class="code" href="larod_8h.html#a3e5686f34427aaa1a2476cc0991adf12">larodMapSetIntArr2</a>(modelParams, <span class="stringliteral">&quot;image.output.size&quot;</span>, 48, 48, NULL);</div><div class="line"></div><div class="line"><a class="code" href="larod_8h.html#a9e56e66ffecad46856d96bc289b6ce5a">larodModel</a> *model = <a class="code" href="larod_8h.html#a41b5e5179aa68b382e024945254a5770">larodLoadModel</a>(conn, -1,</div><div class="line">                                   <a class="code" href="larod_8h.html#a29a9707a190c2d0c44f7e50f942b2621">larodGetDevice</a>(conn, <span class="stringliteral">&quot;cpu-proc&quot;</span>, 0, NULL),</div><div class="line">                                   <a class="code" href="larod_8h.html#a41ad6dc8e9f9ffebc03faf115167aba5afc936d97349d892279eec5c41c154d41">LAROD_ACCESS_PRIVATE</a>, <span class="stringliteral">&quot;nv12-&gt;rgb&quot;</span>,</div><div class="line">                                   modelParams, &amp;error);</div></div><!-- fragment --><p>Every model can be made either public or private by setting the access parameter in <code><a class="el" href="larod_8h.html#a41b5e5179aa68b382e024945254a5770" title="Load a new model. ">larodLoadModel()</a></code>. A private model is only usable by the same session that created it, even though it is visible for everyone, and the model is automatically deleted in the service when the session closes its connection. Making the model public gives everyone permission to use it and one must explicitly call <code><a class="el" href="larod_8h.html#ae91c59650ac4d2352930137749fc5377" title="Delete a loaded model. ">larodDeleteModel()</a></code> to delete the model from the service's pool of loaded models.</p>
<h3>larodTensor</h3>
<p>The input and output of a model are represented by <code>larodTensor</code> objects. Each tensor carries information about the data that is used when running a job, e.g. the file descriptor pointing to the data buffer and various meta data such as the dimensions and data type of the tensor.</p>
<p>There are two main ways of creating the <code>larodTensor</code>s required to run a job on a specific model.</p>
<p>If you already have file descriptors representing the input and output buffers you want to use for your job the easiest method is to use <code><a class="el" href="larod_8h.html#adefd8c496e10eddced5be85d93aceb13" title="Create input tensors from a model. ">larodCreateModelInputs()</a></code> and <code><a class="el" href="larod_8h.html#aab50fc1bcd4fcbc626fdb00d368e49cb" title="Create output tensors from a model. ">larodCreateModelOutputs()</a></code>, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> numInputs = 0;</div><div class="line"><a class="code" href="larod_8h.html#a07d4c60d47a09a1c1508b8f9b8db3783">larodTensor</a>** inputTensors = <a class="code" href="larod_8h.html#adefd8c496e10eddced5be85d93aceb13">larodCreateModelInputs</a>(model, &amp;numInputs, &amp;error);</div></div><!-- fragment --><p> In this way, the tensors will be constructed with the right characteristics to match what the model expects. With this method, it is easy to probe properties of the tensor, i.e. the meta data, with e.g. <code><a class="el" href="larod_8h.html#a63b6236a3d1fc23579e26699acad90dc" title="Get dimensions of a tensor. ">larodGetTensorDims()</a></code> and other similar functions. Now the only fields one has to set for every tensor is the file descriptor that points to the data with <code><a class="el" href="larod_8h.html#a4423cb2a9da02f3a21766a2713edbaa5" title="Set file descriptor of a tensor. ">larodSetTensorFd()</a></code> as well as the properties of the file descriptor using <code><a class="el" href="larod_8h.html#a33a0af9702614ee94936e6cc757c3fad" title="Set the properties for a file descriptor of a tensor. ">larodSetTensorFdProps()</a></code>.</p>
<p>Important properties of a tensor are its <em>dimensions</em>, <em>layout</em> and <em>pitches</em>. The dimensions are interpreted exactly the same way as for the dimensions of a multidimensional array; the layout of the tensor describes the ordering of the dimensions in memory, e.g. the layout <b>NCHW</b> means the ordering: batch size, channel, height and width; lastly, the pitches of a tensor are (most often) the different stride lengths of the dimensions. Accelerators sometimes want specific pitches to align tensors in memory for optimal performance. Visit the documentation of <code><a class="el" href="structlarodTensorDims.html" title="A type containing information about a tensor&#39;s dimensions. ">larodTensorDims</a></code>, <code>larodTensorLayout</code> and <code><a class="el" href="structlarodTensorPitches.html" title="A type containing information about a tensor&#39;s pitches. ">larodTensorPitches</a></code> in <code><a class="el" href="larod_8h.html" title="Main larod header file. ">larod.h</a></code> for detailed explanations; make sure to understand these concepts before interpreting the data of a tensor.</p>
<p>For the properties of the file descriptor, you probably would want to use <code>LAROD_FD_TYPE_DMA</code> or <code>LAROD_FD_TYPE_DISK</code> that already specifies appropriate access flags for common file descriptor types. Setting invalid flags could result in undefined behavior. For example, if one do not set <code>LAROD_FD_PROP_DMABUF</code> for a dma-buf fd but only <code>LAROD_FD_PROP_MAP</code>, it could give inconsistent data results (since the CPU cache would probably not be synchronized correctly). Therefore, always set the correct access flags corresponding to the actual file descriptor type (c.f. <code>LAROD_FD_TYPE_DMA</code> and <code>LAROD_FD_TYPE_DISK</code> in <code><a class="el" href="larod_8h.html" title="Main larod header file. ">larod.h</a></code>)</p>
<p>If you for some further convenience would like larod to also allocate buffers for the tensors you can instead use <code><a class="el" href="larod_8h.html#ad8be991c1295938b95df0c2dbd6d1ad7" title="Create and allocate input tensors from a model. ">larodAllocModelInputs()</a></code> and <code><a class="el" href="larod_8h.html#a39c2cd5fb8f2395f976cc49220e96888" title="Create and allocate output tensors from a model. ">larodAllocModelOutputs()</a></code>, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> numInputs = 0;</div><div class="line"><a class="code" href="larod_8h.html#a07d4c60d47a09a1c1508b8f9b8db3783">larodTensor</a>** inputTensors = <a class="code" href="larod_8h.html#ad8be991c1295938b95df0c2dbd6d1ad7">larodAllocModelInputs</a>(conn, model, 0, &amp;numInputs,</div><div class="line">                                                   NULL, &amp;error);</div></div><!-- fragment --><p> These <code>larodTensor</code>s are also populated with all tensor meta data, and in addition they contain valid file descriptors and properties of these file descriptors. To obtain the file descriptor from one of these tensors <code><a class="el" href="larod_8h.html#a3f6b1aa86a4405bf97dd20fac24dc079" title="Get file descriptor of a tensor. ">larodGetTensorFd()</a></code> should be used.</p>
<p>Notably, for some backends the allocation calls provide the application with options of allocating certain types of buffers (e.g. dma-buf based) that may not otherwise be available to the application (for security reasons).</p>
<p>Any <code>larodTensor</code>, regardless of in which way it was created, must be destroyed explicitly with <code><a class="el" href="larod_8h.html#afac99dfef68ffe3d513008aaac354ae0" title="Destroy a list of larodTensor. ">larodDestroyTensors()</a></code> when it is no longer of interest. This will remove any cachings and allocations of the tensor inside the service as well as freeing up used memory for the tensor in the user's address space.</p>
<h3>larodJobRequest</h3>
<p>Running a job requires a <code>larodJobRequest</code> that is created from a <code>larodModel</code> handle together with the input and output tensors: </p><div class="fragment"><div class="line"><a class="code" href="larod_8h.html#a8f6f0898b3a3c25a07582687b6095265">larodJobRequest</a>* jobReq = <a class="code" href="larod_8h.html#af25e0293b11b12fb8e296fb20c828159">larodCreateJobRequest</a>(model,</div><div class="line">                                                inputTensors, numInputs,</div><div class="line">                                                outputTensors, numOutputs,</div><div class="line">                                                NULL, &amp;error);</div></div><!-- fragment --><p> The job request is executed simply with </p><div class="fragment"><div class="line"><a class="code" href="larod_8h.html#a7c492dcfb18e0a32407dc6078bd50dbe">larodRunJob</a>(conn, jobReq, &amp;error);</div></div><!-- fragment --><p> larod will write the output to the output tensors' file descriptors.</p>
<h3>Asynchronous calls</h3>
<p>The workflow for asynchronous job execution with larod is almost the same as the above, synchronous, one. Loading models and executing jobs can be performed asynchrounosly with the <code><a class="el" href="larod_8h.html#ab4073f88052a8b3c4804683903e84001" title="Load a new model asynchronously. ">larodLoadModelAsync()</a></code> and <code><a class="el" href="larod_8h.html#a3fa258919ed449acf79cff143bc638f3" title="Run a job on a loaded model asynchronously. ">larodRunJobAsync()</a></code> calls. The addition, in the asynchronous case, is that these require the user to define their own callback functions with the signatures </p><div class="fragment"><div class="line">void (*<a class="code" href="larod_8h.html#aa4057108f02e9886b7992bd7726d10c4">larodLoadModelCallback</a>)(<a class="code" href="larod_8h.html#a9e56e66ffecad46856d96bc289b6ce5a">larodModel</a>* model, <span class="keywordtype">void</span>* userData,</div><div class="line">                               <a class="code" href="structlarodError.html">larodError</a>* error);</div><div class="line">void (*<a class="code" href="larod_8h.html#a974a5de759f35ed4b168919acfa7e77b">larodRunJobCallback</a>)(<span class="keywordtype">void</span>* userData, <a class="code" href="structlarodError.html">larodError</a>* error);</div></div><!-- fragment --><p> For example, running <code><a class="el" href="larod_8h.html#a3fa258919ed449acf79cff143bc638f3" title="Run a job on a loaded model asynchronously. ">larodRunJobAsync()</a></code> will return as soon as the job request is scheduled for execution and the given callback function will be executed when the job is finished.</p>
<p>The user is free to pass on any data to the callback function with <code>userData</code> argument, but please note that the function should not carry out relatively extensive blocking tasks; since it would block liblarod's message bus.</p>
<h3>Tensor tracking for performance</h3>
<p>The larod service can track <code>larodTensor</code>s in order to sometimes be able to improve memory access performance. For instance, a <code>larodTensor</code> with the file descriptor property <code>LAROD_FD_PROP_MAP</code> need only be mapped once in the service if it's recurring. This can improve performance a lot.</p>
<p><code>larodTensor</code>s allocated by larod - e.g. using <code><a class="el" href="larod_8h.html#ad8be991c1295938b95df0c2dbd6d1ad7" title="Create and allocate input tensors from a model. ">larodAllocModelInputs()</a></code> - are tracked by default. To enable tracking on <code>larodTensor</code>s using buffers not allocated by larod <code><a class="el" href="larod_8h.html#a4c84b8df7f3efc94276ba8cdaf940f85" title="Start tracking a tensor in the service. ">larodTrackTensor()</a></code> should be used.</p>
<h3>Power management</h3>
<p>Accelerators/devices such as a DLPU may consume a lot of power when inferences are run on them. Embedded systems often have a tight power budget which dictates power-usage levels that must not be exceeded. Because of this, larod is equipped with a feature called a power-controller. The implementation of the power controller could differ between systems because it is an interchangeable part of the service, but in general, the larod service must always request power from the power controller before doing any of the following:</p>
<ul>
<li>Running a job on any backend.</li>
<li>Loading a model on any backend.</li>
</ul>
<p>It is up to the power controller to decide when each backend is allowed to run; however, the power controller may never interrupt an executing backend if the backend was granted power when it started working.</p>
<p>This feature has a single implication in <em>liblarod</em>'s API, which is that the <code><a class="el" href="structlarodError.html" title="Type containing error information. ">larodError</a></code> code <code>LAROD_ERROR_POWER_NOT_AVAILABLE</code> may be returned by functions when there is currently no power available to carry out the request. Applications should (most likely) handle this error code explicitly. The reason for this is that the error is a result of a downtime that is temporary (by design). For some use cases it would make sense to wait for some time and retry the same API call again until <code>LAROD_ERROR_POWER_NOT_AVAILABLE</code> is no longer returned. Another application might instead skip the job altogether and handle it in some other manner (as a non-fatal error). Refer to <code><a class="el" href="larod_8h.html" title="Main larod header file. ">larod.h</a></code> for API functions that may return <code>LAROD_ERROR_POWER_NOT_AVAILABLE</code>.</p>
<h2>Backward compatibility</h2>
<p>liblarod is versioned using <a href="https://semver.org/">semantic versioning</a> and as such the API is only broken in new major releases of liblarod. Further, ABI and API backward compatibility is maintained a period of time after each liblarod major release in order to ease the transition between API breaks for app developers.</p>
<h3>ABI backward compatibility</h3>
<p>ABI backward compatibility means that apps compiled against a liblarod with an older major version are still able to dynamically link perfectly well at runtime with a newer major version of liblarod, and thus does not need to be recompiled to run with that newer version. In other words, an app compiled against a liblarod of major version X &lt; Y still works when linking dynamically with a liblarod of major version Y as long as liblarod Y is ABI backward compatible with liblarod X.</p>
<p>ABI backward compatibility is handled under the hood by symbol versioning in liblarod.</p>
<h3>API backward compatibility</h3>
<p>API backward compatibility means that apps written using the API of an older major version of liblarod are with a minor edit (see below) able to be compiled perfectly well against a newer major version of liblarod, and thus does not need to be rewritten to compile and run with the newer version. In other words, an app written using the liblarod X &lt; Y major version API can with a small edit be made to compile against a liblarod of major version Y as long as liblarod Y is API backward compatible with liblarod X.</p>
<p>In liblarod API backward compatibility is handled by special preprocessing defines that can be defined before including <code><a class="el" href="larod_8h.html" title="Main larod header file. ">larod.h</a></code> to declare which liblarod API version is to be used.</p>
<p>In particular, by defining <code>LAROD_API_VERSION_X</code> before including <code><a class="el" href="larod_8h.html" title="Main larod header file. ">larod.h</a></code> below, it will declare version X of liblarod's functions and types: </p><div class="fragment"><div class="line"><span class="preprocessor">#defined LAROD_API_VERSION_X</span></div><div class="line"><span class="preprocessor">#include &lt;larod.h&gt;</span></div></div><!-- fragment --><p> In this case any function or type present in the liblarod X.*.* API will behave the same way it did when compiled with liblarod X.*.* even though a liblarod of a newer major version Y &gt; X is used to build the app as long as liblarod Y is API backward compatible with liblarod X.</p>
<h2>Future features</h2>
<p>larod is under active development and the following features are not yet part of larod; however, there are plans to implement them.</p>
<h3>Custom layers</h3>
<p>At this stage larod does not support models using custom layers for all devices. However there are plans to implement such support in the future for any hardware that allows custom layers as long as it does not interfere too much with the larod architecture. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2009-2023 Axis Communications AB. All rights reserved.
</small></address>
</body>
</html>
