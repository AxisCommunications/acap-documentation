<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>liblarod: Introduction to larod for app developers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">liblarod
   &#160;<span id="projectnumber">@VERSION_STR@</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction to larod for app developers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#overview">Overview</a><ul>
<li><a href="#purpose-and-scope">Purpose and scope</a></li>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#features">Features</a></li>
</ul>
</li>
<li><a href="#concepts-and-workflow">Concepts and workflow</a><ul>
<li><a href="#larodconnection">larodConnection</a></li>
<li><a href="#larodmodel">larodModel</a></li>
<li><a href="#larodtensor">larodTensor</a></li>
<li><a href="#larodjobrequest">larodJobRequest</a></li>
<li><a href="#asynchronous-calls">Asynchronous calls</a></li>
<li><a href="#tensor-tracking-for-performance">Tensor tracking for performance</a></li>
</ul>
</li>
<li><a href="#backward-compatibility">Backward compatibility</a><ul>
<li><a href="#abi-backward-compatibility">ABI backward compatibility</a></li>
<li><a href="#api-backward-compatibility">API backward compatibility</a></li>
</ul>
</li>
<li><a href="#future-features">Future features</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Overview</h1>
<p>larod provides a simple unified C API for running machine learning and image preprocessing efficiently. No matter what a particular device can provide in terms of hardware for such operations – be it some specialized deep learning hardware accelerator or simply an ARM CPU – the larod API is all you need to access it.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Purpose and scope</h2>
<p>Though the larod API is in some sense quite similar to libraries like Tensorflow Lite and ARMNN the purpose and scope of larod is actually rather different. The main purpose is to wrap other frameworks (like Tensorflow Lite) and thus let users access various different chips (exposing different APIs) through a single unified API. So an application could for example run both preprocessing on a GPU and neural network inference on an ARM CPU on the same device using only the larod API. The native APIs for these chips may be completely different, for example OpenCL and Tensorflow Lite respectively, but larod abstracts these into one simple and unified API.</p>
<p>Furthermore the larod stack is designed to solve a number of other problems as well, for instance related to security, power management and asynchronicity. Please see <a href="#features">features</a> and <a href="#future-features">future features</a> below for more on this.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Architecture</h2>
<p>larod is made up of two components:</p><ul>
<li><em>liblarod</em>: This is the shared library with which applications link dynamically to use larod. As an app developer liblarod, and <code><a class="el" href="larod_8h.html" title="Main larod header file.">larod.h</a></code> in particular, will be your interface.</li>
<li><em>larod service</em>: This is a Linux system service which liblarod communicates with to perform operations on the hardware.</li>
</ul>
<p>By using the functions exposed by liblarod, an application can load neural network models and define preprocessing operations (crop, scale, image color format convert). These models are then used together with input data to create job requests, which are sent to the larod service for execution. Model data as well as input and output data are represented by file descriptors in liblarod.</p>
<p>Below we see an example of two apps using larod on a device that have three different chips supported by larod.</p>
<div class="fragment"><div class="line">         +-----------+      +-----------+</div>
<div class="line">         |           |      |           |</div>
<div class="line">         |   App 1   |      |   App 2   |</div>
<div class="line">         |           |      |           |</div>
<div class="line">         +---------^-+      +-^---------+</div>
<div class="line">                   |          |</div>
<div class="line">              Static/Dynamic linking</div>
<div class="line">                   |          |</div>
<div class="line">                +--v----------v--+</div>
<div class="line">                |                |</div>
<div class="line">                |    liblarod    |</div>
<div class="line">                |                |</div>
<div class="line">                +-------^--------+</div>
<div class="line">                        |</div>
<div class="line">               D-Bus and Unix socket</div>
<div class="line">                        |</div>
<div class="line">                +-------v--------+</div>
<div class="line">                |                |</div>
<div class="line">                |     larod      |</div>
<div class="line">       +--------&gt;    service     &lt;--------+</div>
<div class="line">       |        |                |        |</div>
<div class="line">       |        +-------^--------+        |</div>
<div class="line">       |                |                 |</div>
<div class="line">       |     Chip native SW interfaces    |</div>
<div class="line">       |                |                 |</div>
<div class="line">+------v-----+    +-----v------+    +-----v------+</div>
<div class="line">|            |    |            |    |            |</div>
<div class="line">|   Chip A   |    |   Chip B   |    |   Chip C   |</div>
<div class="line">|            |    |            |    |            |</div>
<div class="line">+------------+    +------------+    +------------+</div>
</div><!-- fragment --><p>Both apps in this example can access all three chips through the same API though the chips' native SW interfaces may be completely different. The larod service will arbitrate job scheduling between the apps to the supported chips.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Features</h2>
<h3><a class="anchor" id="autotoc_md8"></a>
Easy to get started with</h3>
<p>The larod API is very well documented and there are several basic example applications that exhibit how to use it in practice. A simplified <a href="#concepts-and-workflow">workflow</a> is described below together with the essential concepts in liblarod.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Multiple apps per chip</h3>
<p>Many runtime libraries shipped with hardware accelerators (chips) for e.g. exercising neural networks will only let one process (application) access the hardware at the same time. This is of course a problem if there are multiple applications running on the device wanting to run inferences on the hardware at the same time. larod solves this problem by having the larod service acting as a proxy process, "owning" the hardware, through which other applications can access the accelerator.</p>
<h3><a class="anchor" id="autotoc_md10"></a>
Asynchronous</h3>
<p>For any possibly time consuming calls to larod – such as loading a model or running a neural network inference – there are asynchronous versions in larod. This implies that one can for example queue up multiple inferences (possibly on different chips) at once without blocking the program execution of one’s application. Note that larod provides such an interface even though the chip used has a native SW interface that does not support asynchronous calls.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Prioritized jobs</h3>
<p>Sometimes certain jobs are more important to have finish more quickly than others. For example in the case of alternating an object detection model with a classifier model running inferences on the boxes obtained by the object detector. If the object detector must always run for every frame (say 30 fps) and a lot of boxes have been detected, all the classification inferences may block the object detector. To this end priority on inferences are supported in larod. So in this example the object detector inferences could use a higher priority making larod choose those over classification inferences whenever multiple jobs are in the queue.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Image preprocessing</h3>
<p>larod has an interface for simply defining image preprocessing operations like crop, scale, image color format convert, and supports several chips that can perform such operations. Read more on this in <a class="el" href="md_preprocessing.html">preprocessing.md</a>.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Minimal overhead</h3>
<p>In designing and implementing larod, performance has been of utmost importance. Thus one should expect very little overhead (and indeed benchmarks confirm this) compared to using a native runtime library directly.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Capabilities probing</h3>
<p>After loading a model into larod one can through calls to larod extract information from the model, e.g. about the models input or output tensors. For example if one has not constructed the model on one’s own, one may want to know what kind of input tensor(s) the model requires: What is the data type? The layout? The dimensions? larod has the answers!</p>
<h3><a class="anchor" id="autotoc_md15"></a>
Security</h3>
<p>In order for an application to use an accelerator it must have the privileges to do so. Without larod that would mean that for some accelerators an application would get the rights to do things that they should not be allowed to do, like writing to memory that must not be touched. With larod however the applications require no such permissions as larod acts as a proxy process which have all those necessary permissions, through which the applications communicate with the hardware.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
Zero-copy and map only once</h3>
<p>The larod API provides a simple way to avoid any memory copies or mappings of input and output tensor data that are possible to avoid. The application simply declares how their buffers may be accessed and whether they will be used repeatedly, and then larod will take all measures possible to optimize memory accesses on these buffers. This implies both that larod jobs run faster and that larod uses the CPU less so as to leave more resources to other processes.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Concepts and workflow</h1>
<p>The basic workflow of running a job with larod is as follows:</p><ul>
<li>Create a <code>larodConnection</code>.</li>
<li>Construct a <code>larodModel</code>.</li>
<li>Construct input/output <code>larodTensor</code>s and set up their file descriptors pointing to the respective data buffers.</li>
<li>Create a job request out of the <code>larodModel</code> and <code>larodTensor</code> handles.</li>
<li>Execute the job request.</li>
</ul>
<p>A brief description of each step is given below. For details about each function call, see <code><a class="el" href="larod_8h.html" title="Main larod header file.">larod.h</a></code>.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
larodConnection</h2>
<p>Connecting to the larod service and creating a <code>larodConnection</code> is as simple as </p><div class="fragment"><div class="line"><a class="code" href="structlarodError.html">larodError</a>* error = NULL;</div>
<div class="line"><a class="code" href="larod_8h.html#adf976f1fb816101078a7ac0b49a78294">larodConnection</a>* conn = NULL;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="larod_8h.html#ab7337d6d6663c0e45326022503927851">larodConnect</a>(&amp;conn, &amp;error);</div>
</div><!-- fragment --><p>The <code>larodConnection</code> represents the session that an application has with the larod service and is used in all the calls that interact with the service.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
larodModel</h2>
<p>A model represents a computational task with a set of inputs and outputs. The model is loaded onto a specific backend, specified by a <code>larodChip</code>. There are two resources that one can use to configure the model:</p>
<ul>
<li><a class="el" href="md_model-formats.html">Binary data</a> represented by a file descriptor. The data should be in <code>.larod</code> format. To convert e.g. TFLite models, use the ../tools/model-converter/README.md "larod-convert" tool.</li>
<li>A constructed <code>larodMap</code> that contains a set of parameters.</li>
</ul>
<p>Both the type of data that is accepted as well as available parameters are backend specific. Typically, neural networks are loaded with binary data while certain <a class="el" href="md_preprocessing.html">preprocessing</a> operations can be constructed purely from a <code>larodMap</code>.</p>
<p>For example, a TFLite model can be loaded with </p><div class="fragment"><div class="line">FILE* fpModel = fopen(<span class="stringliteral">&quot;mobilenet.larod&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>);</div>
<div class="line"><span class="keywordtype">int</span> fd = fileno(fpModel);</div>
<div class="line"><a class="code" href="larod_8h.html#a9e56e66ffecad46856d96bc289b6ce5a">larodModel</a>* model = <a class="code" href="larod_8h.html#a9617def81b934a2219d6a8f2a6ccdf7f">larodLoadModel</a>(conn, fd, <a class="code" href="larod_8h.html#a5d61d65903803a3c587e5830de34df24a6228dc43b27601fd1a01e4604ebf5a20">LAROD_CHIP_TFLITE_CPU</a>,</div>
<div class="line">                                   <a class="code" href="larod_8h.html#a41ad6dc8e9f9ffebc03faf115167aba5afc936d97349d892279eec5c41c154d41">LAROD_ACCESS_PRIVATE</a>, <span class="stringliteral">&quot;Mobilenet&quot;</span>,</div>
<div class="line">                                   NULL <span class="comment">/*larodMap*/</span>, &amp;error);</div>
</div><!-- fragment --><p>Similarly, a preprocessing model is constructed with </p><div class="fragment"><div class="line"><a class="code" href="larod_8h.html#a480ba7618e79ad250c166c52d216ab79">larodMap</a>* modelParams = <a class="code" href="larod_8h.html#ac7cb26c7b2ef5c99507edd44e7727b0e">larodCreateMap</a>(&amp;error);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="larod_8h.html#a28e4db02130ffb4c0a19fac84b698ce0">larodMapSetStr</a>(modelParams, <span class="stringliteral">&quot;image.input.format&quot;</span>, <span class="stringliteral">&quot;nv12&quot;</span>, NULL);</div>
<div class="line"><a class="code" href="larod_8h.html#a3e5686f34427aaa1a2476cc0991adf12">larodMapSetIntArr2</a>(modelParams, <span class="stringliteral">&quot;image.input.size&quot;</span>, 1280, 720, NULL);</div>
<div class="line"><a class="code" href="larod_8h.html#a28e4db02130ffb4c0a19fac84b698ce0">larodMapSetStr</a>(modelParams, <span class="stringliteral">&quot;image.output.format&quot;</span>, <span class="stringliteral">&quot;rgb-interleaved&quot;</span>, NULL);</div>
<div class="line"><a class="code" href="larod_8h.html#a3e5686f34427aaa1a2476cc0991adf12">larodMapSetIntArr2</a>(modelParams, <span class="stringliteral">&quot;image.output.size&quot;</span>, 48, 48, NULL);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="larod_8h.html#a9e56e66ffecad46856d96bc289b6ce5a">larodModel</a> *model = <a class="code" href="larod_8h.html#a9617def81b934a2219d6a8f2a6ccdf7f">larodLoadModel</a>(conn, -1, <a class="code" href="larod_8h.html#a5d61d65903803a3c587e5830de34df24a0444d4c3c924311308e7bd61479dc99d">LAROD_CHIP_LIBYUV</a>,</div>
<div class="line">                                   <a class="code" href="larod_8h.html#a41ad6dc8e9f9ffebc03faf115167aba5afc936d97349d892279eec5c41c154d41">LAROD_ACCESS_PRIVATE</a>, <span class="stringliteral">&quot;nv12-&gt;rgb&quot;</span>,</div>
<div class="line">                                   modelParams, &amp;error);</div>
</div><!-- fragment --><p>Every model can be made either public or private by setting the access parameter in <code><a class="el" href="larod_8h.html#a9617def81b934a2219d6a8f2a6ccdf7f" title="Load a new model.">larodLoadModel()</a></code>. A private model is only usable by the same session that created it, even though it is visible for everyone, and the model is automatically deleted in the service when the session closes its connection. Making the model public gives everyone permission to use it and one must explicitly call <code><a class="el" href="larod_8h.html#ae91c59650ac4d2352930137749fc5377" title="Delete a loaded model.">larodDeleteModel()</a></code> to delete the model from the service's pool of loaded models.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
larodTensor</h2>
<p>The input and output of a model are represented by <code>larodTensor</code> objects. Each tensor carries information about the data that is used when running a job, e.g. the file descriptor pointing to the data buffer and various meta data such as the dimensions and data type of the tensor.</p>
<p>There are two main ways of creating the <code>larodTensor</code>s required to run a job on a specific model.</p>
<p>If you already have file descriptors representing the input and output buffers you want to use for your job the easiest method is to use <code><a class="el" href="larod_8h.html#adefd8c496e10eddced5be85d93aceb13" title="Create input tensors from a model.">larodCreateModelInputs()</a></code> and <code><a class="el" href="larod_8h.html#aab50fc1bcd4fcbc626fdb00d368e49cb" title="Create output tensors from a model.">larodCreateModelOutputs()</a></code>, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> numInputs = 0;</div>
<div class="line"><a class="code" href="larod_8h.html#a07d4c60d47a09a1c1508b8f9b8db3783">larodTensor</a>** inputTensors = <a class="code" href="larod_8h.html#adefd8c496e10eddced5be85d93aceb13">larodCreateModelInputs</a>(model, &amp;numInputs, &amp;error);</div>
</div><!-- fragment --><p>In this way, the tensors will be constructed with the right characteristics to match what the model expects. With this method, it is easy to probe properties of the tensor, i.e. the meta data, with e.g. <code><a class="el" href="larod_8h.html#a63b6236a3d1fc23579e26699acad90dc" title="Get dimensions of a tensor.">larodGetTensorDims()</a></code> and other similar functions. Now the only fields one has to set for every tensor is the file descriptor that points to the data with <code><a class="el" href="larod_8h.html#a4423cb2a9da02f3a21766a2713edbaa5" title="Set file descriptor of a tensor.">larodSetTensorFd()</a></code> as well as the properties of the file descriptor using <code><a class="el" href="larod_8h.html#a33a0af9702614ee94936e6cc757c3fad" title="Set the properties for a file descriptor of a tensor.">larodSetTensorFdProps()</a></code>.</p>
<p>If you for some further convenience would like larod to also allocate buffers for the tensors you can instead use <code><a class="el" href="larod_8h.html#ad8be991c1295938b95df0c2dbd6d1ad7" title="Create and allocate input tensors from a model.">larodAllocModelInputs()</a></code> and <code><a class="el" href="larod_8h.html#a39c2cd5fb8f2395f976cc49220e96888" title="Create and allocate output tensors from a model.">larodAllocModelOutputs()</a></code>, e.g. </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> numInputs = 0;</div>
<div class="line"><a class="code" href="larod_8h.html#a07d4c60d47a09a1c1508b8f9b8db3783">larodTensor</a>** inputTensors = <a class="code" href="larod_8h.html#ad8be991c1295938b95df0c2dbd6d1ad7">larodAllocModelInputs</a>(conn, model, 0, &amp;numInputs,</div>
<div class="line">                                                   NULL, &amp;error);</div>
</div><!-- fragment --><p>These <code>larodTensor</code>s are also populated with all tensor meta data, and in addition they contain valid file descriptors and properties of these file descriptors. To obtain the file descriptor from one of these tensors <code><a class="el" href="larod_8h.html#a3f6b1aa86a4405bf97dd20fac24dc079" title="Get file descriptor of a tensor.">larodGetTensorFd()</a></code> should be used.</p>
<p>Notably, for some backends the allocation calls provide the application with options of allocating certain types of buffers (e.g. dma-buf based) that may not otherwise be available to the application (for security reasons).</p>
<h2><a class="anchor" id="autotoc_md21"></a>
larodJobRequest</h2>
<p>Running a job requires a <code>larodJobRequest</code> that is created from a <code>larodModel</code> handle together with the input and output tensors: </p><div class="fragment"><div class="line"><a class="code" href="larod_8h.html#a8f6f0898b3a3c25a07582687b6095265">larodJobRequest</a>* jobReq = <a class="code" href="larod_8h.html#af25e0293b11b12fb8e296fb20c828159">larodCreateJobRequest</a>(model,</div>
<div class="line">                                                inputTensors, numInputs,</div>
<div class="line">                                                outputTensors, numOutputs,</div>
<div class="line">                                                NULL, &amp;error);</div>
</div><!-- fragment --><p>The job request is executed simply with </p><div class="fragment"><div class="line"><a class="code" href="larod_8h.html#a7c492dcfb18e0a32407dc6078bd50dbe">larodRunJob</a>(conn, jobReq, &amp;error);</div>
</div><!-- fragment --><p>larod will write the output to the output tensors' file descriptors.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Asynchronous calls</h2>
<p>The workflow for asynchronous job execution with larod is almost the same as the above, synchronous, one. Loading models and executing jobs can be performed asynchrounosly with the <code><a class="el" href="larod_8h.html#a3331d06f78b120923c96d06affd46619" title="Load a new model asynchronously.">larodLoadModelAsync()</a></code> and <code><a class="el" href="larod_8h.html#a3fa258919ed449acf79cff143bc638f3" title="Run a job on a loaded model asynchronously.">larodRunJobAsync()</a></code> calls. The addition, in the asynchronous case, is that these require the user to define their own callback functions with the signatures </p><div class="fragment"><div class="line">void (*<a class="code" href="larod_8h.html#aa4057108f02e9886b7992bd7726d10c4">larodLoadModelCallback</a>)(<a class="code" href="larod_8h.html#a9e56e66ffecad46856d96bc289b6ce5a">larodModel</a>* model, <span class="keywordtype">void</span>* userData,</div>
<div class="line">                               <a class="code" href="structlarodError.html">larodError</a>* error);</div>
<div class="line">void (*<a class="code" href="larod_8h.html#a974a5de759f35ed4b168919acfa7e77b">larodRunJobCallback</a>)(<span class="keywordtype">void</span>* userData, <a class="code" href="structlarodError.html">larodError</a>* error);</div>
</div><!-- fragment --><p>For example, running <code><a class="el" href="larod_8h.html#a3fa258919ed449acf79cff143bc638f3" title="Run a job on a loaded model asynchronously.">larodRunJobAsync()</a></code> will return as soon as the job request is scheduled for execution and the given callback function will be executed when the job is finished.</p>
<p>The user is free to pass on any data to the callback function with <code>userData</code> argument, but please note that the function should not carry out relatively extensive blocking tasks; since it would block liblarod's message bus.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Tensor tracking for performance</h2>
<p>The larod service can track <code>larodTensor</code>s in order to sometimes be able to improve memory access performance. For instance, a <code>larodTensor</code> with the file descriptor property <code>LAROD_FD_PROP_MAP</code> need only be mapped once in the service if it's recurring. This can improve performance a lot.</p>
<p><code>larodTensor</code>s allocated by larod - e.g. using <code><a class="el" href="larod_8h.html#ad8be991c1295938b95df0c2dbd6d1ad7" title="Create and allocate input tensors from a model.">larodAllocModelInputs()</a></code> - are tracked by default. To enable tracking on <code>larodTensor</code>s using buffers not allocated by larod <code><a class="el" href="larod_8h.html#a4c84b8df7f3efc94276ba8cdaf940f85" title="Start tracking a tensor in the service.">larodTrackTensor()</a></code> should be used.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
Backward compatibility</h1>
<p>liblarod is versioned using <a href="https://semver.org/">semantic versioning</a> and as such the API is only broken in new major releases of liblarod. Further, ABI and API backward compatibility is maintained a period of time after each liblarod major release in order to ease the transition between API breaks for app developers.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
ABI backward compatibility</h2>
<p>ABI backward compatibility means that apps compiled against a liblarod with an older major version are still able to dynamically link perfectly well at runtime with a newer major version of liblarod, and thus does not need to be recompiled to run with that newer version. In other words, an app compiled against a liblarod of major version X &lt; Y still works when linking dynamically with a liblarod of major version Y as long as liblarod Y is ABI backward compatible with liblarod X.</p>
<p>ABI backward compatibility is handled under the hood by symbol versioning in liblarod.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
API backward compatibility</h2>
<p>API backward compatibility means that apps written using the API of an older major version of liblarod are with a minor edit (see below) able to be compiled perfectly well against a newer major version of liblarod, and thus does not need to be rewritten to compile and run with the newer version. In other words, an app written using the liblarod X &lt; Y major version API can with a small edit be made to compile against a liblarod of major version Y as long as liblarod Y is API backward compatible with liblarod X.</p>
<p>In liblarod API backward compatibility is handled by special preprocessing defines that can be defined before including <code><a class="el" href="larod_8h.html" title="Main larod header file.">larod.h</a></code> to declare which liblarod API version is to be used.</p>
<p>In particular, by defining <code>LAROD_API_VERSION_X</code> before including <code><a class="el" href="larod_8h.html" title="Main larod header file.">larod.h</a></code> below, it will declare version X of liblarod's functions and types: </p><div class="fragment"><div class="line"><span class="preprocessor">#defined LAROD_API_VERSION_X</span></div>
<div class="line"><span class="preprocessor">#include &lt;larod.h&gt;</span></div>
</div><!-- fragment --><p>In this case any function or type present in the liblarod X.*.* API will behave the same way it did when compiled with liblarod X.*.* even though a liblarod of a newer major version Y &gt; X is used to build the app as long as liblarod Y is API backward compatible with liblarod X.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Future features</h1>
<p>larod is under active development and the following features are not yet part of larod; however, there are plans to implement them.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Custom layers</h2>
<p>At this stage larod does not support models using custom layers for all chips. However there are plans to implement such support in the future for any hardware that allows custom layers as long as it does not interfere too much with the larod architecture.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Power management</h2>
<p>Many accelerators use a lot of power when running jobs on them. Devices typically have a tight power budget which dictates power usage levels that must not be exceeded. If for example a camera needs to run a power hungry task not related to an accelerator such as switching an IR filter, then jobs on the accelerator must be paused for a while. larod will automatically delay running jobs on the hardware in such a scenario by keeping track of the power usage on the camera, and an application using larod does not have to worry about it at all. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="alarod_8h_html_a07d4c60d47a09a1c1508b8f9b8db3783"><div class="ttname"><a href="larod_8h.html#a07d4c60d47a09a1c1508b8f9b8db3783">larodTensor</a></div><div class="ttdeci">struct larodTensor larodTensor</div><div class="ttdoc">A type representing a tensor.</div><div class="ttdef"><b>Definition:</b> larod.h:397</div></div>
<div class="ttc" id="alarod_8h_html_ab7337d6d6663c0e45326022503927851"><div class="ttname"><a href="larod_8h.html#ab7337d6d6663c0e45326022503927851">larodConnect</a></div><div class="ttdeci">bool larodConnect(larodConnection **conn, larodError **error)</div><div class="ttdoc">Connect to larod.</div></div>
<div class="ttc" id="alarod_8h_html_a8f6f0898b3a3c25a07582687b6095265"><div class="ttname"><a href="larod_8h.html#a8f6f0898b3a3c25a07582687b6095265">larodJobRequest</a></div><div class="ttdeci">struct larodJobRequest larodJobRequest</div><div class="ttdoc">Type describing a job request.</div><div class="ttdef"><b>Definition:</b> larod.h:388</div></div>
<div class="ttc" id="alarod_8h_html_a28e4db02130ffb4c0a19fac84b698ce0"><div class="ttname"><a href="larod_8h.html#a28e4db02130ffb4c0a19fac84b698ce0">larodMapSetStr</a></div><div class="ttdeci">bool larodMapSetStr(larodMap *map, const char *key, const char *value, larodError **error)</div><div class="ttdoc">Add a string to a larodMap object.</div></div>
<div class="ttc" id="alarod_8h_html_af25e0293b11b12fb8e296fb20c828159"><div class="ttname"><a href="larod_8h.html#af25e0293b11b12fb8e296fb20c828159">larodCreateJobRequest</a></div><div class="ttdeci">larodJobRequest * larodCreateJobRequest(const larodModel *model, larodTensor **inputTensors, size_t numInputs, larodTensor **outputTensors, size_t numOutputs, larodMap *params, larodError **error)</div><div class="ttdoc">Create and initialize a job request handle.</div></div>
<div class="ttc" id="alarod_8h_html_a3e5686f34427aaa1a2476cc0991adf12"><div class="ttname"><a href="larod_8h.html#a3e5686f34427aaa1a2476cc0991adf12">larodMapSetIntArr2</a></div><div class="ttdeci">bool larodMapSetIntArr2(larodMap *map, const char *key, const int64_t value0, const int64_t value1, larodError **error)</div><div class="ttdoc">Add an integer array of two elements to a larodMap object.</div></div>
<div class="ttc" id="alarod_8h_html_a974a5de759f35ed4b168919acfa7e77b"><div class="ttname"><a href="larod_8h.html#a974a5de759f35ed4b168919acfa7e77b">larodRunJobCallback</a></div><div class="ttdeci">void(* larodRunJobCallback)(void *userData, larodError *error)</div><div class="ttdoc">Callback used in larodRunJobAsync().</div><div class="ttdef"><b>Definition:</b> larod.h:373</div></div>
<div class="ttc" id="alarod_8h_html_a9617def81b934a2219d6a8f2a6ccdf7f"><div class="ttname"><a href="larod_8h.html#a9617def81b934a2219d6a8f2a6ccdf7f">larodLoadModel</a></div><div class="ttdeci">larodModel * larodLoadModel(larodConnection *conn, const int fd, const larodChip chip, const larodAccess access, const char *name, const larodMap *params, larodError **error)</div><div class="ttdoc">Load a new model.</div></div>
<div class="ttc" id="alarod_8h_html_a41ad6dc8e9f9ffebc03faf115167aba5afc936d97349d892279eec5c41c154d41"><div class="ttname"><a href="larod_8h.html#a41ad6dc8e9f9ffebc03faf115167aba5afc936d97349d892279eec5c41c154d41">LAROD_ACCESS_PRIVATE</a></div><div class="ttdeci">@ LAROD_ACCESS_PRIVATE</div><div class="ttdoc">Private access.</div><div class="ttdef"><b>Definition:</b> larod.h:101</div></div>
<div class="ttc" id="alarod_8h_html_a5d61d65903803a3c587e5830de34df24a0444d4c3c924311308e7bd61479dc99d"><div class="ttname"><a href="larod_8h.html#a5d61d65903803a3c587e5830de34df24a0444d4c3c924311308e7bd61479dc99d">LAROD_CHIP_LIBYUV</a></div><div class="ttdeci">@ LAROD_CHIP_LIBYUV</div><div class="ttdoc">CPU with libyuv.</div><div class="ttdef"><b>Definition:</b> larod.h:85</div></div>
<div class="ttc" id="alarod_8h_html_adefd8c496e10eddced5be85d93aceb13"><div class="ttname"><a href="larod_8h.html#adefd8c496e10eddced5be85d93aceb13">larodCreateModelInputs</a></div><div class="ttdeci">larodTensor ** larodCreateModelInputs(const larodModel *model, size_t *numTensors, larodError **error)</div><div class="ttdoc">Create input tensors from a model.</div></div>
<div class="ttc" id="alarod_8h_html_a480ba7618e79ad250c166c52d216ab79"><div class="ttname"><a href="larod_8h.html#a480ba7618e79ad250c166c52d216ab79">larodMap</a></div><div class="ttdeci">struct larodMap larodMap</div><div class="ttdoc">A type containing key-value pairs.</div><div class="ttdef"><b>Definition:</b> larod.h:408</div></div>
<div class="ttc" id="alarod_8h_html_adf976f1fb816101078a7ac0b49a78294"><div class="ttname"><a href="larod_8h.html#adf976f1fb816101078a7ac0b49a78294">larodConnection</a></div><div class="ttdeci">struct larodConnection larodConnection</div><div class="ttdoc">Connection handle type for the larod service.</div><div class="ttdef"><b>Definition:</b> larod.h:381</div></div>
<div class="ttc" id="alarod_8h_html_a9e56e66ffecad46856d96bc289b6ce5a"><div class="ttname"><a href="larod_8h.html#a9e56e66ffecad46856d96bc289b6ce5a">larodModel</a></div><div class="ttdeci">struct larodModel larodModel</div><div class="ttdoc">A type representing a model.</div><div class="ttdef"><b>Definition:</b> larod.h:338</div></div>
<div class="ttc" id="alarod_8h_html_ad8be991c1295938b95df0c2dbd6d1ad7"><div class="ttname"><a href="larod_8h.html#ad8be991c1295938b95df0c2dbd6d1ad7">larodAllocModelInputs</a></div><div class="ttdeci">larodTensor ** larodAllocModelInputs(larodConnection *conn, const larodModel *model, const uint32_t fdPropFlags, size_t *numTensors, larodMap *params, larodError **error)</div><div class="ttdoc">Create and allocate input tensors from a model.</div></div>
<div class="ttc" id="alarod_8h_html_ac7cb26c7b2ef5c99507edd44e7727b0e"><div class="ttname"><a href="larod_8h.html#ac7cb26c7b2ef5c99507edd44e7727b0e">larodCreateMap</a></div><div class="ttdeci">larodMap * larodCreateMap(larodError **error)</div><div class="ttdoc">Create new larodMap.</div></div>
<div class="ttc" id="alarod_8h_html_a7c492dcfb18e0a32407dc6078bd50dbe"><div class="ttname"><a href="larod_8h.html#a7c492dcfb18e0a32407dc6078bd50dbe">larodRunJob</a></div><div class="ttdeci">bool larodRunJob(larodConnection *conn, const larodJobRequest *jobReq, larodError **error)</div><div class="ttdoc">Run a job on a loaded model.</div></div>
<div class="ttc" id="astructlarodError_html"><div class="ttname"><a href="structlarodError.html">larodError</a></div><div class="ttdoc">Type containing error information.</div><div class="ttdef"><b>Definition:</b> larod.h:248</div></div>
<div class="ttc" id="alarod_8h_html_aa4057108f02e9886b7992bd7726d10c4"><div class="ttname"><a href="larod_8h.html#aa4057108f02e9886b7992bd7726d10c4">larodLoadModelCallback</a></div><div class="ttdeci">void(* larodLoadModelCallback)(larodModel *model, void *userData, larodError *error)</div><div class="ttdoc">Callback used in larodLoadModelAsync().</div><div class="ttdef"><b>Definition:</b> larod.h:356</div></div>
<div class="ttc" id="alarod_8h_html_a5d61d65903803a3c587e5830de34df24a6228dc43b27601fd1a01e4604ebf5a20"><div class="ttname"><a href="larod_8h.html#a5d61d65903803a3c587e5830de34df24a6228dc43b27601fd1a01e4604ebf5a20">LAROD_CHIP_TFLITE_CPU</a></div><div class="ttdeci">@ LAROD_CHIP_TFLITE_CPU</div><div class="ttdoc">CPU with TensorFlow Lite.</div><div class="ttdef"><b>Definition:</b> larod.h:72</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 15 2021 08:50:11 for liblarod by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
